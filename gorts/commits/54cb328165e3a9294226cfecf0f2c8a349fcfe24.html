<!DOCTYPE html>
<html lang="en" style="font-family: monospace;"><head><title>[54cb328165] implement netstring helpers on both Go &amp; Tcl | gorts | Boast</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><strong><a href="../../">Repos</a> / <a href="../">gorts</a> / 54cb328165</strong><hr><pre>commit 54cb328165e3a9294226cfecf0f2c8a349fcfe24
Author: Nh√¢n &lt;hi@imnhan.com&gt;
Date:   Wed Jun 21 18:55:48 2023 +0700

    implement netstring helpers on both Go &amp; Tcl

diff --git a/Makefile b/Makefile
index 885462b..31971fd 100644
--- a/Makefile
+++ b/Makefile
@@ -20,6 +20,10 @@ dist/GORTS-Linux.zip: linux
 watch:
 	find . -name &#39;*.go&#39; -o -name &#39;*.tcl&#39; | entr -rc go run .
 
+# I only have tests on the netstring package now
+test:
+	find ./netstring -name &#39;*.go&#39; | entr -rc go test ./netstring
+
 gorts.png: gorts.svg
 	convert -background transparent -density 300 -resize 256x256 gorts.svg gorts.png
 
diff --git a/netstring/netstring.go b/netstring/netstring.go
new file mode 100644
index 0000000..20c2506
--- /dev/null
+++ b/netstring/netstring.go
@@ -0,0 +1,38 @@
+// This package implements just enough [netstrings]
+// for our homebrew IPC solution.
+//
+// [netstrings]: https://cr.yp.to/proto/netstrings.txt
+package netstring
+
+import (
+	&quot;bytes&quot;
+	&quot;fmt&quot;
+	&quot;strconv&quot;
+)
+
+func Encode(s string) string {
+	return fmt.Sprintf(&quot;%d:%s,&quot;, len(s), s)
+}
+
+// A SplitFunc to be used in a bufio.Scanner
+func SplitFunc(data []byte, atEOF bool) (advance int, token []byte, err error) {
+	colonIndex := bytes.IndexRune(data, &#39;:&#39;)
+	if colonIndex == -1 {
+		// Haven&#39;t fully read the length part yet =&gt; skip:
+		return 0, nil, nil
+	}
+
+	length, err := strconv.Atoi(string(data[:colonIndex]))
+	if err != nil {
+		return 0, nil, fmt.Errorf(&quot;split netstring: %w&quot;, err)
+	}
+
+	rest := data[colonIndex+1:]
+	if len(rest) &lt; length+1 { // +1 for &quot;,&quot; at the end
+		// Haven&#39;t read the whole netstring yet =&gt; skip:
+		return 0, nil, nil
+	}
+
+	// The whole netstring should now be within the buffer
+	return colonIndex + 1 + length + 1, rest[:length], nil
+}
diff --git a/netstring/netstring_test.go b/netstring/netstring_test.go
new file mode 100644
index 0000000..5636180
--- /dev/null
+++ b/netstring/netstring_test.go
@@ -0,0 +1,50 @@
+package netstring
+
+import (
+	&quot;bufio&quot;
+	&quot;strings&quot;
+	&quot;testing&quot;
+)
+
+func TestEncode(t *testing.T) {
+	var tests = []struct {
+		in  string
+		out string
+	}{
+		{&quot;hello world!&quot;, &quot;12:hello world!,&quot;},
+		{&quot;&quot;, &quot;0:,&quot;},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.in, func(t *testing.T) {
+			ans := Encode(tt.in)
+			if ans != tt.out {
+				t.Errorf(&quot;Encode(): got %s | want %s&quot;, ans, tt.out)
+			}
+		})
+	}
+}
+
+func TestSplit(t *testing.T) {
+	in := strings.NewReader(&quot;5:hello,6:world!,0:,&quot;)
+	want := []string{&quot;hello&quot;, &quot;world!&quot;, &quot;&quot;}
+
+	t.Run(&quot;Split&quot;, func(t *testing.T) {
+		var results []string
+		scanner := bufio.NewScanner(in)
+		scanner.Split(SplitFunc)
+		for scanner.Scan() {
+			netstring := scanner.Text()
+			results = append(results, netstring)
+		}
+
+		if len(results) != len(want) {
+			t.Errorf(&quot;Split(): got %s | want %s&quot;, results, want)
+		}
+		for i, actual := range results {
+			if actual != want[i] {
+				t.Errorf(&quot;Split()[%d]: got %s | want %s&quot;, i, results, want)
+			}
+		}
+	})
+}
diff --git a/tcl/netstring.tcl b/tcl/netstring.tcl
new file mode 100644
index 0000000..fa510b1
--- /dev/null
+++ b/tcl/netstring.tcl
@@ -0,0 +1,25 @@
+proc netstring {s} {
+    set len [string length $s]
+    return &quot;$len:$s,&quot;
+}
+
+proc netstrings {strings} {
+    set result &quot;&quot;
+    foreach s $strings {
+        set result [string cat $result [netstring $s]]
+    }
+    return [netstring $result]
+}
+
+proc readnetstring {chan} {
+    set data &quot;&quot;
+    set char &quot;&quot;
+    while {$char != &quot;:&quot;} {
+        set char [read $chan 1]
+        set data [string cat $data $char]
+    }
+    set nslen [string range $data 0 {end-1}]
+    set nstr [read $chan $nslen]
+    read $chan 1; # consume the trailing &quot;,&quot;
+    return $nstr
+}
</pre></body></html>