<!DOCTYPE html>
<html lang="en" style="font-family: monospace;"><head><title>[2d994cf953] scraping task queue put/pop | pytaku | Boast</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><strong><a href="../../">Repos</a> / <a href="../">pytaku</a> / 2d994cf953</strong><hr><pre>commit 2d994cf953fc6dd20e54f7f1e1687db564e90ff2
Author: Bùi Thành Nhân &lt;hi@imnhan.com&gt;
Date:   Sun May 24 18:38:47 2020 +0700

    scraping task queue put/pop

diff --git a/src/pytaku_scraper/management/commands/purge_queue.py b/src/pytaku_scraper/management/commands/purge_queue.py
new file mode 100644
index 0000000..fe66b48
--- /dev/null
+++ b/src/pytaku_scraper/management/commands/purge_queue.py
@@ -0,0 +1,17 @@
+from django.core.management.base import BaseCommand
+
+from pytaku_scraper.models import TaskQueue
+
+
+class Command(BaseCommand):
+    help = &quot;Delete all tasks in a queue.&quot;
+
+    def add_arguments(self, parser):
+        parser.add_argument(&quot;task&quot;, choices=[&quot;scrape&quot;])
+
+    def handle(self, *args, **options):
+        task = options[&quot;task&quot;]
+        assert task == &quot;scrape&quot;
+
+        count, _ = TaskQueue.objects.filter(name=task).delete()
+        print(f&#39;Deleted {count} &quot;{task}&quot; tasks.&#39;)
diff --git a/src/pytaku_scraper/management/commands/put_tasks.py b/src/pytaku_scraper/management/commands/put_tasks.py
new file mode 100644
index 0000000..5e85e94
--- /dev/null
+++ b/src/pytaku_scraper/management/commands/put_tasks.py
@@ -0,0 +1,25 @@
+from django.core.management.base import BaseCommand
+
+from pytaku_scraper.models import TaskQueue
+
+
+class Command(BaseCommand):
+    help = &quot;Puts various tasks.&quot;
+
+    def add_arguments(self, parser):
+        parser.add_argument(&quot;task&quot;, choices=[&quot;scrape&quot;])
+        parser.add_argument(&quot;start_id&quot;, type=int)
+        parser.add_argument(&quot;end_id&quot;, type=int)
+
+    def handle(self, *args, **options):
+        assert options[&quot;task&quot;] == &quot;scrape&quot;
+
+        result = TaskQueue.put_bulk(
+            &quot;scrape&quot;,
+            [
+                {&quot;url&quot;: f&quot;https://mangadex.org/api/?type=manga&amp;id={i}&quot;}
+                for i in range(options[&quot;start_id&quot;], options[&quot;end_id&quot;] + 1)
+            ],
+        )
+
+        print(&quot;Result:&quot;, result)
diff --git a/src/pytaku_scraper/management/commands/scrape.py b/src/pytaku_scraper/management/commands/scrape.py
new file mode 100644
index 0000000..c1fe0cf
--- /dev/null
+++ b/src/pytaku_scraper/management/commands/scrape.py
@@ -0,0 +1,30 @@
+import requests
+from django.core.management.base import BaseCommand
+from django.db import transaction
+
+from pytaku_scraper.models import ScrapeAttempt, TaskQueue
+
+
+class Command(BaseCommand):
+    help = &quot;Scrape worker. Run as many as needed.&quot;
+
+    def handle(self, *args, **options):
+        task_name = &quot;scrape&quot;
+
+        while True:
+            with transaction.atomic():
+                task = TaskQueue.pop(task_name)
+                task_id = task.id
+                print(f&quot;Processing task {task_id}: {task.payload}&quot;)
+                resp = requests.get(task.payload[&quot;url&quot;], timeout=30)
+                assert resp.status_code in (200, 404), f&quot;Unexpected error: {resp.text}&quot;
+
+                ScrapeAttempt.objects.create(
+                    url=task.payload[&quot;url&quot;],
+                    method=&quot;get&quot;,  # TODO
+                    resp_body=resp.text,
+                    resp_status=resp.status_code,
+                )
+
+                task.finish()
+                print(&quot;Done task&quot;, task_id)
diff --git a/src/pytaku_scraper/migrations/0001_initial.py b/src/pytaku_scraper/migrations/0001_initial.py
new file mode 100644
index 0000000..75291d0
--- /dev/null
+++ b/src/pytaku_scraper/migrations/0001_initial.py
@@ -0,0 +1,43 @@
+# Generated by Django 3.0.5 on 2020-05-24 11:32
+
+import django.contrib.postgres.fields.jsonb
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    initial = True
+
+    dependencies = [
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name=&#39;ScrapeAttempt&#39;,
+            fields=[
+                (&#39;id&#39;, models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=&#39;ID&#39;)),
+                (&#39;scraped_at&#39;, models.DateTimeField(auto_now_add=True)),
+                (&#39;url&#39;, models.CharField(max_length=1024)),
+                (&#39;method&#39;, models.CharField(max_length=7)),
+                (&#39;headers&#39;, django.contrib.postgres.fields.jsonb.JSONField(default=dict)),
+                (&#39;body&#39;, models.TextField()),
+                (&#39;resp_body&#39;, models.TextField()),
+                (&#39;resp_status&#39;, models.IntegerField()),
+            ],
+            options={
+                &#39;db_table&#39;: &#39;scrape_attempt&#39;,
+            },
+        ),
+        migrations.CreateModel(
+            name=&#39;TaskQueue&#39;,
+            fields=[
+                (&#39;id&#39;, models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=&#39;ID&#39;)),
+                (&#39;created_at&#39;, models.DateTimeField(auto_now_add=True)),
+                (&#39;name&#39;, models.CharField(choices=[(&#39;Scrape&#39;, &#39;scrape&#39;)], max_length=100)),
+                (&#39;payload&#39;, django.contrib.postgres.fields.jsonb.JSONField(default=dict)),
+            ],
+            options={
+                &#39;db_table&#39;: &#39;task_queue&#39;,
+            },
+        ),
+    ]
diff --git a/src/pytaku_scraper/migrations/__init__.py b/src/pytaku_scraper/migrations/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/src/pytaku_scraper/models.py b/src/pytaku_scraper/models.py
index 8ca2a54..0ff5391 100644
--- a/src/pytaku_scraper/models.py
+++ b/src/pytaku_scraper/models.py
@@ -4,6 +4,58 @@
 QUEUE_NAMES = [(&quot;Scrape&quot;, &quot;scrape&quot;)]
 
 
+class TaskQueue(models.Model):
+    &quot;&quot;&quot;
+    Simple postgres-backed task queue.
+    Supports concurrent consumers thanks to SELECT FOR UPDATE SKIP LOCKED.
+
+    Usage:
+        - Create task: TaskQueue.put() or TaskQueue.put_bulk()
+        - Consume task:
+            with transaction.atomic():
+                task = TaskQueue.pop()
+                # do work with task
+                task.finish()
+        - If anything goes wrong between pop() and finish(),
+          the task is automatically put back in the queue.
+    &quot;&quot;&quot;
+
+    class Meta:
+        db_table = &quot;task_queue&quot;
+
+    created_at = models.DateTimeField(auto_now_add=True)
+    name = models.CharField(max_length=100, choices=QUEUE_NAMES)
+    payload = JSONField(default=dict)
+
+    @classmethod
+    def put(cls, name, payload):
+        return cls.objects.create(name=name, payload=payload)
+
+    @classmethod
+    def put_bulk(cls, name, payloads):
+        return cls.objects.bulk_create(
+            [cls(name=name, payload=payload) for payload in payloads]
+        )
+
+    @classmethod
+    def pop(cls, name):
+        &quot;&quot;&quot;
+        SELECT FOR UPDATE SKIP LOCKED.
+        Must be run inside a transaction.
+
+        Remember to call instance.finish() once you&#39;re done.
+        &quot;&quot;&quot;
+        return (
+            TaskQueue.objects.select_for_update(skip_locked=True)
+            .filter(name=name)
+            .order_by(&quot;id&quot;)
+            .first()
+        )
+
+    def finish(self):
+        return self.delete()
+
+
 class ScrapeAttempt(models.Model):
     class Meta:
         db_table = &quot;scrape_attempt&quot;
@@ -17,11 +69,3 @@ class Meta:
 
     resp_body = models.TextField()
     resp_status = models.IntegerField()
-
-
-class TaskQueue(models.Model):
-    class Meta:
-        db_table = &quot;task_queue&quot;
-
-    created_at = models.DateTimeField(auto_now_add=True)
-    name = models.CharField(max_length=100, choices=QUEUE_NAMES)
</pre></body></html>